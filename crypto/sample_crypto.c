#include "sample_crypto.h"
#include "fh_crypto_api.h"

static const unsigned char plain_text[] =
{
	0x6b,0xc1,0xbe,0xe2, 0x2e,0x40,0x9f,0x96, 0xe9,0x3d,0x7e,0x11, 0x73,0x93,0x17,0x2a,
	0xae,0x2d,0x8a,0x57, 0x1e,0x03,0xac,0x9c, 0x9e,0xb7,0x6f,0xac, 0x45,0xaf,0x8e,0x51,
	0x30,0xc8,0x1c,0x46, 0xa3,0x5c,0xe4,0x11, 0xe5,0xfb,0xc1,0x19, 0x1a,0x0a,0x52,0xef,
	0xf6,0x9f,0x24,0x45, 0xdf,0x4f,0x9b,0x17, 0xad,0x2b,0x41,0x7b, 0xe6,0x6c,0x37,0x10,
};

//================ aes cbc =====================
static const unsigned char aes_cbc_iv_buf[] =
{
	0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07, 0x08,0x09,0x0a,0x0b, 0x0c,0x0d,0x0e,0x0f,
};

static const unsigned char aes_cbc_key_buf[] =
{
	0x2b,0x7e,0x15,0x16, 0x28,0xae,0xd2,0xa6, 0xab,0xf7,0x15,0x88, 0x09,0xcf,0x4f,0x3c,
};

static const unsigned char aes_cbc_encrypt_text[] =
{
	0x76,0x49,0xab,0xac, 0x81,0x19,0xb2,0x46, 0xce,0xe9,0x8e,0x9b, 0x12,0xe9,0x19,0x7d,
	0x50,0x86,0xcb,0x9b, 0x50,0x72,0x19,0xee, 0x95,0xdb,0x11,0x3a, 0x91,0x76,0x78,0xb2,
	0x73,0xbe,0xd6,0xb8, 0xe3,0xc1,0x74,0x3b, 0x71,0x16,0xe6,0x9e, 0x22,0x22,0x95,0x16,
	0x3f,0xf1,0xca,0xa1, 0x68,0x1f,0xac,0x09, 0x12,0x0e,0xca,0x30, 0x75,0x86,0xe1,0xa7,
};

//================ aes ecb =====================
static const unsigned char aes_ecb_key_buf[] =
{
	0x60,0x3d,0xeb,0x10, 0x15,0xca,0x71,0xbe, 0x2b,0x73,0xae,0xf0, 0x85,0x7d,0x77,0x81,
	0x1f,0x35,0x2c,0x07, 0x3b,0x61,0x08,0xd7, 0x2d,0x98,0x10,0xa3, 0x09,0x14,0xdf,0xf4,
};

static const unsigned char aes_ecb_encrypt_text[] =
{
	0xf3,0xee,0xd1,0xbd, 0xb5,0xd2,0xa0,0x3c, 0x06,0x4b,0x5a,0x7e, 0x3d,0xb1,0x81,0xf8,
	0x59,0x1c,0xcb,0x10, 0xd4,0x10,0xed,0x26, 0xdc,0x5b,0xa7,0x4a, 0x31,0x36,0x28,0x70,
	0xb6,0xed,0x21,0xb9, 0x9c,0xa6,0xf4,0xf9, 0xf1,0x53,0xe7,0xb1, 0xbe,0xaf,0xed,0x1d,
	0x23,0x30,0x4b,0x7a, 0x39,0xf9,0xf3,0xff, 0x06,0x7d,0x8d,0x8f, 0x9e,0x24,0xec,0xc7,
};

//================ aes ctr =====================
static const unsigned char aes_ctr_iv_buf[] =
{
	0xf0,0xf1,0xf2,0xf3, 0xf4,0xf5,0xf6,0xf7, 0xf8,0xf9,0xfa,0xfb, 0xfc,0xfd,0xfe,0xff,
};

static const unsigned char aes_ctr_key_buf[] =
{
	0x8e,0x73,0xb0,0xf7, 0xda,0x0e,0x64,0x52, 0xc8,0x10,0xf3,0x2b, 0x80,0x90,0x79,0xe5,
	0x62,0xf8,0xea,0xd2, 0x52,0x2c,0x6b,0x7b,
};

static const unsigned char aes_ctr_plain_text[] =
{
	0x6b,0xc1,0xbe,0xe2, 0x2e,0x40,0x9f,0x96, 0xe9,0x3d,0x7e,0x11, 0x73,0x93,0x17,0x2a,
	0xae,0x2d,0x8a,0x57, 0x1e,0x03,0xac,0x9c, 0x9e,0xb7,0x6f,0xac, 0x45,0xaf,0x8e,0x51,
	0x30,0xc8,0x1c,0x46, 0xa3,0x5c,0xe4,0x11, 0xe5,0xfb,0xc1,0x19, 0x1a,0x0a,0x52,0xef,
	0xf6,0x9f,0x24,0x45, 0xdf,0x4f,0x9b,0x17, 0xad,0x2b,0x41,0x7b, 0xe6,0x6c,0x37,0x10,
};

static const unsigned char aes_ctr_encrypt_text[] =
{
	0x1a,0xbc,0x93,0x24,	0x17,0x52,0x1c,0xa2,	0x4f,0x2b,0x04,0x59,	0xfe,0x7e,0x6e,0x0b,
	0x09,0x03,0x39,0xec,	0x0a,0xa6,0xfa,0xef,	0xd5,0xcc,0xc2,0xc6,	0xf4,0xce,0x8e,0x94,
	0x1e,0x36,0xb2,0x6b,	0xd1,0xeb,0xc6,0x70,	0xd1,0xbd,0x1d,0x66,	0x56,0x20,0xab,0xf7,
	0x4f,0x78,0xa7,0xf6,	0xd2,0x98,0x09,0x58,	0x5a,0x97,0xda,0xec,	0x58,0xc6,0xb0,0x50,
};

//================ aes ofb =====================
static const unsigned char aes_ofb_iv_buf[] =
{
	0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07, 0x08,0x09,0x0a,0x0b, 0x0c,0x0d,0x0e,0x0f,
};

static const unsigned char aes_ofb_key_buf[] =
{
	0x60,0x3d,0xeb,0x10, 0x15,0xca,0x71,0xbe, 0x2b,0x73,0xae,0xf0, 0x85,0x7d,0x77,0x81,
	0x1f,0x35,0x2c,0x07, 0x3b,0x61,0x08,0xd7, 0x2d,0x98,0x10,0xa3, 0x09,0x14,0xdf,0xf4,
};

static const unsigned char aes_ofb_plain_text[] =
{
	0x6b,0xc1,0xbe,0xe2, 0x2e,0x40,0x9f,0x96, 0xe9,0x3d,0x7e,0x11, 0x73,0x93,0x17,0x2a,
	0xae,0x2d,0x8a,0x57, 0x1e,0x03,0xac,0x9c, 0x9e,0xb7,0x6f,0xac, 0x45,0xaf,0x8e,0x51,
	0x30,0xc8,0x1c,0x46, 0xa3,0x5c,0xe4,0x11, 0xe5,0xfb,0xc1,0x19, 0x1a,0x0a,0x52,0xef,
	0xf6,0x9f,0x24,0x45, 0xdf,0x4f,0x9b,0x17, 0xad,0x2b,0x41,0x7b, 0xe6,0x6c,0x37,0x10,
};

static const unsigned char aes_ofb_encrypt_text[] =
{
	0xdc,0x7e,0x84,0xbf,0xda,0x79,0x16,0x4b,0x7e,0xcd,0x84,0x86,0x98,0x5d,0x38,0x60,
	0x4f,0xeb,0xdc,0x67,0x40,0xd2,0x0b,0x3a,0xc8,0x8f,0x6a,0xd8,0x2a,0x4f,0xb0,0x8d,
	0x71,0xab,0x47,0xa0,0x86,0xe8,0x6e,0xed,0xf3,0x9d,0x1c,0x5b,0xba,0x97,0xc4,0x08,
	0x01,0x26,0x14,0x1d,0x67,0xf3,0x7b,0xe8,0x53,0x8f,0x5a,0x8b,0xe7,0x40,0xe4,0x84,
};

//================ des ecb =====================
static const unsigned char des_ecb_key_buf[] =
{
	0x01,0x01,0x01,0x01, 0x01,0x01,0x01,0x01,
};

static const unsigned char des_ecb_plain_text[] =
{
	0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

static const unsigned char des_ecb_encrypt_text[] =
{
	0x95,0xF8,0xA5,0xE5,0xDD,0x31,0xD9,0x00,0xDD,0x7F,0x12,0x1C,0xA5,0x01,0x56,0x19,
	0x2E,0x86,0x53,0x10,0x4F,0x38,0x34,0xEA,0x4B,0xD3,0x88,0xFF,0x6C,0xD8,0x1D,0x4F,
	0x20,0xB9,0xE7,0x67,0xB2,0xFB,0x14,0x56,0x55,0x57,0x93,0x80,0xD7,0x71,0x38,0xEF,
	0x6C,0xC5,0xDE,0xFA,0xAF,0x04,0x51,0x2F,0x0D,0x9F,0x27,0x9B,0xA5,0xD8,0x72,0x60,
};

//================ des cbc =====================
static const unsigned char des_cbc_key_buf[] =
{
	0x01,0x23,0x45,0x67, 0x89,0xab,0xcd,0xef,
};

static const unsigned char des_cbc_iv_buf[] =
{
	0x12,0x34,0x56,0x78, 0x90,0xab,0xcd,0xef,
};

static const unsigned char des_cbc_plain_text[] =
{
	0x4e,0x6f,0x77,0x20,0x69,0x73,0x20,0x74,0x68,0x65,0x20,0x74,0x69,0x6d,0x65,0x20,
	0x66,0x6f,0x72,0x20,0x61,0x6c,0x6c,0x20,

};

static const unsigned char des_cbc_encrypt_text[] =
{
	0xe5,0xc7,0xcd,0xde,0x87,0x2b,0xf2,0x7c,0x43,0xe9,0x34,0x00,0x8c,0x38,0x9c,0x0f,
	0x68,0x37,0x88,0x49,0x9a,0x7c,0x05,0xf6,
};

//================ des ofb =====================
static const unsigned char des_ofb_key_buf[] =
{
	0x01,0x23,0x45,0x67, 0x89,0xab,0xcd,0xef,
};

static const unsigned char des_ofb_iv_buf[] =
{
	0x12,0x34,0x56,0x78, 0x90,0xab,0xcd,0xef,
};

static const unsigned char des_ofb_plain_text[] =
{
	0x4e,0x6f,0x77,0x20,0x69,0x73,0x20,0x74,0x43,0xe9,0x34,0x00,0x8c,0x38,0x9c,0x0f,
	0x68,0x37,0x88,0x49,0x9a,0x7c,0x05,0xf6,
};

static const unsigned char des_ofb_encrypt_text[] =
{
	0xf3,0x09,0x62,0x49,0xc7,0xf4,0x6e,0x51,0x1e,0x7e,0x5e,0x50,0xcb,0xbe,0xc4,0x10,
	0x33,0x35,0xa1,0x8a,0xde,0x4a,0x91,0x15,
};

//================ des3 ecb =====================
static const unsigned char des3_ecb_key_buf[] =
{
	0x01,0x23,0x45,0x67, 0x89,0xab,0xcd,0xef, 0x23,0x45,0x67,0x89, 0xab,0xcd,0xef,0x01,
	0x45,0x67,0x89,0xab, 0xcd,0xef,0x01,0x23,
};

static const unsigned char des3_ecb_plain_text[] =
{
	0x4e,0x6f,0x77,0x20,0x69,0x73,0x20,0x74,0x43,0xe9,0x34,0x00,0x8c,0x38,0x9c,0x0f,
	0x68,0x37,0x88,0x49,0x9a,0x7c,0x05,0xf6,
};

static const unsigned char des3_ecb_encrypt_text[] =
{
	0x31,0x4f,0x83,0x27,0xfa,0x7a,0x09,0xa8,0xd5,0x89,0x5f,0xad,0xe9,0x8f,0xae,0xdf,
	0x98,0xf4,0x70,0xeb,0x35,0x53,0xa5,0xda,
};

//================ des3 cbc =====================
static const unsigned char des3_cbc_key_buf[] =
{
	0x01,0x23,0x45,0x67, 0x89,0xab,0xcd,0xef, 0x23,0x45,0x67,0x89, 0xab,0xcd,0xef,0x01,
	0x45,0x67,0x89,0xab, 0xcd,0xef,0x01,0x23,
};

static const unsigned char des3_cbc_iv_buf[] =
{
	0x12,0x34,0x56,0x78, 0x90,0xab,0xcd,0xef,
};

static const unsigned char des3_cbc_plain_text[] =
{
	0x4e,0x6f,0x77,0x20,0x69,0x73,0x20,0x74,0x43,0xe9,0x34,0x00,0x8c,0x38,0x9c,0x0f,
	0x68,0x37,0x88,0x49,0x9a,0x7c,0x05,0xf6,
};

static const unsigned char des3_cbc_encrypt_text[] =
{
	0xf3,0xc0,0xff,0x02,0x6c,0x02,0x30,0x89,0xc4,0x3a,0xdd,0x8f,0xd8,0xcd,0x5e,0x43,
	0x2b,0xfd,0x41,0xd3,0x13,0x0b,0xcf,0x40,
};


CRYPTO_CASE stCryptoCase[] =
{
	{
		.stCryptoCtrl.enKeySrc = CRYPTO_KEY_SRC_USER,
		.stCryptoCtrl.enAlg = CRYPTO_ALG_AES,
		.stCryptoCtrl.enWorkMode = CRYPTO_WORK_MODE_CBC,
		.stCryptoCtrl.enKeyLen = CRYPTO_KEY_AES_128BIT,
		.stCryptoCtrl.enIVLen = CRYPTO_IV_KEY_AES_128BIT,
		.key_buf = (uint8_t*)aes_cbc_key_buf,
		.key_size = sizeof(aes_cbc_key_buf),
		.iv_buf = (uint8_t*)aes_cbc_iv_buf,
		.iv_size = sizeof(aes_cbc_iv_buf),
		.encrypto_buf = (uint8_t*)plain_text,
		.decrypto_buf = (uint8_t*)aes_cbc_encrypt_text,
		.crypto_size = 64,
		.name = "aes_cbc",
	},
	{
		.stCryptoCtrl.enKeySrc = CRYPTO_KEY_SRC_USER,
		.stCryptoCtrl.enAlg = CRYPTO_ALG_AES,
		.stCryptoCtrl.enWorkMode = CRYPTO_WORK_MODE_ECB,
		.stCryptoCtrl.enKeyLen = CRYPTO_KEY_AES_256BIT,
		.stCryptoCtrl.enIVLen = CRYPTO_IV_KEY_AES_0BIT,
		.key_buf = (uint8_t*)aes_ecb_key_buf,
		.key_size = sizeof(aes_ecb_key_buf),
		.iv_buf = NULL,
		.iv_size = 0,
		.encrypto_buf = (uint8_t*)plain_text,
		.decrypto_buf = (uint8_t*)aes_ecb_encrypt_text,
		.crypto_size = 64,
		.name = "aes_ecb",
	},
	{
		.stCryptoCtrl.enKeySrc = CRYPTO_KEY_SRC_USER,
		.stCryptoCtrl.enAlg = CRYPTO_ALG_AES,
		.stCryptoCtrl.enWorkMode = CRYPTO_WORK_MODE_CTR,
		.stCryptoCtrl.enKeyLen = CRYPTO_KEY_AES_192BIT,
		.stCryptoCtrl.enIVLen = CRYPTO_IV_KEY_AES_128BIT,
		.key_buf = (uint8_t*)aes_ctr_key_buf,
		.key_size = sizeof(aes_ctr_key_buf),
		.iv_buf = (uint8_t*)aes_ctr_iv_buf,
		.iv_size = sizeof(aes_ctr_iv_buf),
		.encrypto_buf = (uint8_t*)aes_ctr_plain_text,
		.decrypto_buf = (uint8_t*)aes_ctr_encrypt_text,
		.crypto_size = 64,
		.name = "aes_ctr",
	},
	{
		.stCryptoCtrl.enKeySrc = CRYPTO_KEY_SRC_USER,
		.stCryptoCtrl.enAlg = CRYPTO_ALG_AES,
		.stCryptoCtrl.enWorkMode = CRYPTO_WORK_MODE_OFB,
		.stCryptoCtrl.enKeyLen = CRYPTO_KEY_AES_256BIT,
		.stCryptoCtrl.enIVLen = CRYPTO_IV_KEY_AES_128BIT,
		.key_buf = (uint8_t*)aes_ofb_key_buf,
		.key_size = sizeof(aes_ofb_key_buf),
		.iv_buf = (uint8_t*)aes_ofb_iv_buf,
		.iv_size = sizeof(aes_ofb_iv_buf),
		.encrypto_buf = (uint8_t*)aes_ofb_plain_text,
		.decrypto_buf = (uint8_t*)aes_ofb_encrypt_text,
		.crypto_size = 64,
		.name = "aes_ofb",
	},
	{
		.stCryptoCtrl.enKeySrc = CRYPTO_KEY_SRC_USER,
		.stCryptoCtrl.enAlg = CRYPTO_ALG_DES,
		.stCryptoCtrl.enWorkMode = CRYPTO_WORK_MODE_ECB,
		.stCryptoCtrl.enKeyLen = CRYPTO_KEY_DES,
		.stCryptoCtrl.enIVLen = CRYPTO_IV_KEY_AES_0BIT,
		.key_buf = (uint8_t*)des_ecb_key_buf,
		.key_size = sizeof(des_ecb_key_buf),
		.iv_buf = NULL,
		.iv_size = 0,
		.encrypto_buf = (uint8_t*)des_ecb_plain_text,
		.decrypto_buf = (uint8_t*)des_ecb_encrypt_text,
		.crypto_size = 64,
		.name = "des_ecb",
	},
	{
		.stCryptoCtrl.enKeySrc = CRYPTO_KEY_SRC_USER,
		.stCryptoCtrl.enAlg = CRYPTO_ALG_DES,
		.stCryptoCtrl.enWorkMode = CRYPTO_WORK_MODE_CBC,
		.stCryptoCtrl.enKeyLen = CRYPTO_KEY_DES,
		.stCryptoCtrl.enIVLen = CRYPTO_IV_KEY_AES_64BIT,
		.key_buf = (uint8_t*)des_cbc_key_buf,
		.key_size = sizeof(des_cbc_key_buf),
		.iv_buf = (uint8_t*)des_cbc_iv_buf,
		.iv_size = sizeof(des_cbc_iv_buf),
		.encrypto_buf = (uint8_t*)des_cbc_plain_text,
		.decrypto_buf = (uint8_t*)des_cbc_encrypt_text,
		.crypto_size = 24,
		.name = "des_cbc",
	},
	{
		.stCryptoCtrl.enKeySrc = CRYPTO_KEY_SRC_USER,
		.stCryptoCtrl.enAlg = CRYPTO_ALG_DES,
		.stCryptoCtrl.enWorkMode = CRYPTO_WORK_MODE_OFB,
		.stCryptoCtrl.enKeyLen = CRYPTO_KEY_DES,
		.stCryptoCtrl.enIVLen = CRYPTO_IV_KEY_AES_64BIT,
		.key_buf = (uint8_t*)des_ofb_key_buf,
		.key_size = sizeof(des_ofb_key_buf),
		.iv_buf = (uint8_t*)des_ofb_iv_buf,
		.iv_size = sizeof(des_ofb_iv_buf),
		.encrypto_buf = (uint8_t*)des_ofb_plain_text,
		.decrypto_buf = (uint8_t*)des_ofb_encrypt_text,
		.crypto_size = 24,
		.name = "des_ofb",
	},
	{
		.stCryptoCtrl.enKeySrc = CRYPTO_KEY_SRC_USER,
		.stCryptoCtrl.enAlg = CRYPTO_ALG_3DES,
		.stCryptoCtrl.enWorkMode = CRYPTO_WORK_MODE_ECB,
		.stCryptoCtrl.enKeyLen = CRYPTO_KEY_DES_3KEY,
		.stCryptoCtrl.enIVLen = CRYPTO_IV_KEY_AES_0BIT,
		.key_buf = (uint8_t*)des3_ecb_key_buf,
		.key_size = sizeof(des3_ecb_key_buf),
		.iv_buf = NULL,
		.iv_size = 0,
		.encrypto_buf = (uint8_t*)des3_ecb_plain_text,
		.decrypto_buf = (uint8_t*)des3_ecb_encrypt_text,
		.crypto_size = 24,
		.name = "des3_ecb",
	},
	{
		.stCryptoCtrl.enKeySrc = CRYPTO_KEY_SRC_USER,
		.stCryptoCtrl.enAlg = CRYPTO_ALG_3DES,
		.stCryptoCtrl.enWorkMode = CRYPTO_WORK_MODE_CBC,
		.stCryptoCtrl.enKeyLen = CRYPTO_KEY_DES_3KEY,
		.stCryptoCtrl.enIVLen = CRYPTO_IV_KEY_AES_64BIT,
		.key_buf = (uint8_t*)des3_cbc_key_buf,
		.key_size = sizeof(des3_cbc_key_buf),
		.iv_buf = (uint8_t*)des3_cbc_iv_buf,
		.iv_size = sizeof(des3_cbc_iv_buf),
		.encrypto_buf = (uint8_t*)des3_cbc_plain_text,
		.decrypto_buf = (uint8_t*)des3_cbc_encrypt_text,
		.crypto_size = 24,
		.name = "des3_cbc",
	},
};

int main(int argc, char const *argv[])
{
	int ret, i, use_efuse = 0, use_deviceid = 0;
	CRYPTO_HANDLE pCryptoHandle;
	uint8_t result[256];
	CRYPTO_CASE *testcase;

	if(argc > 1)
		use_efuse = atoi(argv[1]);

	if(argc > 2)
		use_deviceid = atoi(argv[2]);

	ret = FH_CRYPTO_Init();
	if(ret < 0)
	{
		printf("FH_CRYPTO_Init failed, ret=%d\n", ret);
	}
	FH_CRYPTO_CreateHandle(&pCryptoHandle);

	// if(use_deviceid)
	// {
	// 	uint8_t device_id[15] =
	// 	{
	// 		0x11, 0x22, 0x33, 0x44, 0x55,
	// 		0x66, 0x77, 0x88, 0x99, 0xaa,
	// 		0xbb, 0xcc, 0xdd, 0xee, 0xff
	// 	};

	// 	ret = FH_CRYPTO_WriteOTPDeviceID(device_id, 15);
	// 	if(ret < 0)
	// 	{
	// 		printf("FH_CRYPTO_WriteOTPDeviceID failed, ret=%d\n", ret);
	// 	}
	// 	memset(result, 0, sizeof(result));

	// 	ret = FH_CRYPTO_ReadOTPDeviceID(result, 15);
	// 	if(ret < 0)
	// 	{
	// 		printf("FH_CRYPTO_ReadOTPDeviceID failed, ret=%d\n", ret);
	// 	}

	// 	printf("device id: ");
	// 	for(i=0; i<15; i++)
	// 		printf("0x%x,", result[i]);
	// 	printf("\n");
	// }

	for(i=0; i<(sizeof(stCryptoCase) / sizeof(CRYPTO_CASE)); i++)
	{
		testcase = &stCryptoCase[i];

		printf("===============start %s============\n", testcase->name);

		memcpy(testcase->stCryptoCtrl.u32Key, testcase->key_buf, testcase->key_size);
		if(testcase->iv_buf)
			memcpy(testcase->stCryptoCtrl.u32IV, testcase->iv_buf, testcase->iv_size);

		ret = FH_CRYPTO_ConfigHandle(&pCryptoHandle, &testcase->stCryptoCtrl);
		if(ret < 0)
		{
			printf("FH_CRYPTO_ConfigHandle failed, ret=%d\n", ret);
		}

		if( use_efuse && (testcase->stCryptoCtrl.enKeySrc == CRYPTO_KEY_SRC_EFUSE))
		{
			ret = FH_CRYPTO_WriteOTPKey(0, (uint8_t *)stCryptoCase[0].stCryptoCtrl.u32Key,
					stCryptoCase[0].key_size);

			if(ret < 0)
			{
				printf("FH_CRYPTO_WriteOTPKey failed, ret=%d\n", ret);
			}
		}
		printf("testcase->key_src: %d, pCryptoHandle->enKeySrc: %d\n",
				testcase->stCryptoCtrl.enKeySrc, pCryptoHandle.enKeySrc);
		memset(result, 0, sizeof(result));

		FH_CRYPTO_Encrypt(&pCryptoHandle, (uint32_t)testcase->encrypto_buf,
				(uint32_t)result, testcase->crypto_size);

		ret = memcmp(testcase->decrypto_buf, result, testcase->crypto_size);

		if (0 != ret)
		{
			printf("CRYPTO_Encrypt memcmp failed, ret=%d\n", ret);
			int j;
			for(j=0; j<testcase->crypto_size; j++)
			{
				if(testcase->encrypto_buf[j] != result[j])
				{
					printf("no: %d, encrypto buff: 0x%x, result: 0x%x\n",
							j, testcase->encrypto_buf[j], result[j]);
				}
			}

		}
		else
		{
			printf("CRYPTO_Encrypt memcmp pass\n");
		}

		memset(result, 0, sizeof(result));

		FH_CRYPTO_Decrypt(&pCryptoHandle, (uint32_t)testcase->decrypto_buf,
				(uint32_t)result, testcase->crypto_size);

		ret = memcmp(testcase->encrypto_buf, result, testcase->crypto_size);

		if (0 != ret)
		{
			printf("CRYPTO_Decrypt memcmp failed, ret=%d\n", ret);
			int j;
			for(j=0; j<testcase->crypto_size; j++)
			{
				if(testcase->decrypto_buf[j] != result[j])
				{
					printf("no: %d, decrypto buff: 0x%x, result: 0x%x\n",
							j, testcase->decrypto_buf[j], result[j]);
				}
			}

		}
		else
		{
			printf("CRYPTO_Decrypt memcmp pass\n");
		}

	}

	ret = FH_CRYPTO_DestroyHandle(&pCryptoHandle);
	if(ret < 0)
	{
		printf("FH_CRYPTO_DestroyHandle failed, ret=%d\n", ret);
	}

	ret = FH_CRYPTO_DeInit();
	if(ret < 0)
	{
		printf("FH_CRYPTO_DeInit failed, ret=%d\n", ret);
	}

	return 0;
}
